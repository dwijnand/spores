<!DOCTYPE html>
<html class="no-js" lang="eng" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serializing spores</title>
    <link rel="stylesheet" href="_theme/css/foundation.min.css">
    <link rel="stylesheet" href="_theme/css/app.css">
     <link rel="stylesheet" href="_theme/css/highlight.js/styles/github-gist.css"> 
  </head>
  <body>
    <div class="expanded row">
      <div class="small-12 medium-12 large-12 columns align-self-top">
        <div class="row">
          
          <header class="large-12 columns align-self-top a_header">
            <div class="row">
              <div class="large-12 columns a_limited top-bar">
                <div class="top-bar-left">
                  <p>Spores</p>

                </div>
                <div class="top-bar-right align-right row">
                  
                  
                    <form action="site-search.html" method="get" class="align-right a_search">
                      <input name="q" type="search"  placeholder="Search
" >
                      <button><img alt="&#1F50D;" src="_theme/images/images/search.svg" /></button>
                    </form>
                  
                </div>
              </div>
            </div>
          </header>
          
          <div class="small-12 medium-12 large-12 columns align-self-top a_limited a_main">
            <div class="row">
              
              <main class="columns large-order-2 sections" id="_sections">
                <h1 id="serializing-spores" class="a_section" data-magellan-target="serializing-spores">Serializing spores<a class="a_hlink" href="#serializing-spores"></a></h1>
<p>Spores can be serialized using two mechanisms: implicit-based pickling libraries
or <code class="hljs">{java.io, scala}.Serializable</code>-based libraries. In this tutorial, we will
explore the integration of spores with Java-based serialization alternatives,
and show how they can be used in Spark to provide a safer use of closures.</p>
<h2 id="goal" class="a_section" data-magellan-target="goal">Goal<a class="a_hlink" href="#goal"></a></h2>
<p>Help Spark users identify serialization issues at compile-time rather than
runtime. Concretely, this translates into addressing <a href="http://www.cakesolutions.net/teamblogs/demystifying-spark-serialisation-error">common</a> [1]
<a href="https://databricks.gitbooks.io/databricks-spark-knowledge-base/content/troubleshooting/javaionotserializableexception.html">serialization issues</a> [2].</p>
<h2 id="installation" class="a_section" data-magellan-target="installation">Installation<a class="a_hlink" href="#installation"></a></h2>
<p>Add the following sbt settings to your <code class="hljs">build.sbt</code>:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">libraryDependencies += <span class="hljs-string">"ch.epfl.scala"</span> %% <span class="hljs-string">"spores"</span> % <span class="hljs-string">"0.4.3"</span>
addCompilerPlugin(<span class="hljs-string">"ch.epfl.scala"</span> %% <span class="hljs-string">"spores-serialization"</span> % <span class="hljs-string">"0.4.3"</span>)
</code></pre>
</div>
<blockquote class="note">
<p>These artifacts are only compatible with Scala 2.11.x.
A <a href="https://issues.scala-lang.org/browse/SI-10009">bug in 2.12.0</a> prevents us from releasing
a compatible version. <code class="hljs">spores</code> will be probably released for 2.12.1.</p>
</blockquote>
<h2 id="quickstart" class="a_section" data-magellan-target="quickstart">Quickstart<a class="a_hlink" href="#quickstart"></a></h2>
<p>Spores allow you to control the environment of a closure. To ensure that spores
are serializable-safe, all the captured variables are checked to be serializable.</p>
<p>This compiler plugin requires you to:</p>
<ol>
<li>Extend <code class="hljs">scala.Serializable</code> in the classes of all the captured types.</li>
<li>Close the class hierarchy of all the custom classes that you capture (<a href="java-serialization.html#closed-class-hierarchies">what is this?</a>).</li>
</ol>
<p>With these requirements, <code class="hljs">spores-serialization</code> makes a best effort to ensure the
correct serializability of your spores.</p>
<h3 id="an-example" class="a_section" data-magellan-target="an-example">An example<a class="a_hlink" href="#an-example"></a></h3>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">scala&gt; <span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">import</span> scala.spores._

scala&gt; <span class="hljs-keyword">val</span> s = spore {
     |   <span class="hljs-keyword">val</span> capturedInt = <span class="hljs-number">8</span>
     |   <span class="hljs-keyword">val</span> capturedString = <span class="hljs-string">"Hello, World!"</span>
     |   <span class="hljs-keyword">val</span> capturedList = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
     |   (i: <span class="hljs-type">Int</span>) =&gt; {
     |     println(capturedString)
     |     capturedList.map(_ + i).contains(capturedInt)
     |   }
     | }
s: scala.spores.<span class="hljs-type">SporeWithEnv</span>[<span class="hljs-type">Int</span>,<span class="hljs-type">Boolean</span>]{<span class="hljs-keyword">val</span> captured: (<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>, <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]); <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Captured</span> </span>= (<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>, <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>])} = &lt;function1&gt;
</code></pre>
</div>
<p>This code snippet compiles because primitives and <code class="hljs">{Scala, Java}</code> collections are serializable.
In it, we capture an <code class="hljs">Int</code>, a <code class="hljs">String</code> and a <code class="hljs">List[Int]</code> which can be successfully
sent over the wire.</p>
<p>But, why? The compiler plugin inspects the type of <code class="hljs">capturedInt</code>, <code class="hljs">capturedString</code> and
<code class="hljs">capturedList</code>. In this case, <code class="hljs">Int</code> is a primitive, <code class="hljs">String</code> extends <code class="hljs">java.io.Serializable</code>
and <code class="hljs">List[Int]</code> is a closed class hierarchy with a primitive (and serializable) type argument
whose subclasses are safely serializable.</p>
<p>The compiler plugin performs a similar reasoning to the one explained before
to verify that certain types are serializable. Since Scala is very flexible and
allows users to abstract over their logic, <code class="hljs">spores-serialization</code> is able to perform
such analysis in more sophisticated situations.</p>
<p>Before introducing them, let's understand the underlying concepts and guarantees
that the transitive checks provide.</p>
<h2 id="basics" class="a_section" data-magellan-target="basics">Basics<a class="a_hlink" href="#basics"></a></h2>
<h3 id="closed-class-hierarchies" class="a_section" data-magellan-target="closed-class-hierarchies">Closed class hierarchies<a class="a_hlink" href="#closed-class-hierarchies"></a></h3>
<p>Closed class hierarchies play a key role in Scala because:</p>
<ul>
<li>they allow the compiler to <a href="https://en.wikipedia.org/wiki/Closed-world_assumption">assume a closed-world</a> for a concrete set of classes;</li>
<li>macros and compiler plugins have <em>full</em> access to their definition and properties.</li>
</ul>
<p>This section sheds some light on the differences between the two and why
<code class="hljs">spores-serialization</code> requires closed class hierarchies to ensure the correct
serializability of your program.</p>
<h4 id="the-class-hierarchy" class="a_section" data-magellan-target="the-class-hierarchy">The class hierarchy<a class="a_hlink" href="#the-class-hierarchy"></a></h4>
<p>Traditionally, class hierarchies have always be open. Open class hierarchies
are handy and flexible for developers: they allow them to extend classes in any
file or project they want (if they are <em>visible</em>). However, such flexibility
hinders the static analysis of programs. To overcome this limitation, we use
closed class hierarchies.</p>
<div class="row"><div class="small-expand columns a_xscroll a_table"><table>
<thead>
<tr><th>Open class hierarchy</th><th>Closed class hierarchy</th></tr>
</thead>
<tbody>
<tr><td><code class="language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span></td><td><code class="language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span></span></code></td></tr>
<tr><td><code class="language-scala"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">b: Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span></code></td><td><code class="language-scala"><span class="hljs-keyword">final </span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">b: Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span></code></td></tr>
<tr><td><code class="language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">b: Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span></code></td><td><code class="language-scala"><span class="hljs-keyword">final </span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">b: Int</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span></code></td></tr>
</tbody>
</table></div></div>
<p>A closed class hierarchy is a finite set of classes that share the same hierarchy and are defined
in the same Scala file. They are defined as their counterpart except for the use of extra modifiers.
The rule of thumb is to define all the leafs as <code class="hljs">final</code>, and the root and intermediate traits
and classes as <code class="hljs">sealed</code>. Therefore, whenever you try to extend a sealed trait/class
or a <code class="hljs">final</code> class, the compiler will throw a happy error at you.</p>
<h4 id="motivation-of-sealed-class-hierarchies" class="a_section" data-magellan-target="motivation-of-sealed-class-hierarchies">Motivation of sealed class hierarchies<a class="a_hlink" href="#motivation-of-sealed-class-hierarchies"></a></h4>
<p>Transitive checking requires a full traversal of the class hierarchy. It needs to check
both class and trait definitions and <em>all their members</em> to prove that no serialization issues
can happen at runtime.</p>
<p>So, why can't we just use open class hierarchies?</p>
<p>Because:</p>
<ol>
<li>Non-<code class="hljs">final</code> classes can be extended elsewhere. <code class="hljs">spores-serialization</code> could give false
positives if these externally defined classes are not serializable.</li>
<li>Intermediate super classes cannot be <code class="hljs">final</code>. Scala needs to guarantee that these classes
are only defined in the current compilation unit, otherwise false positives could happen.</li>
<li>The Scala compiler does not give us access to direct subclasses if the class hierarchy
is not sealed. This is a well-known <a href="https://issues.scala-lang.org/browse/SI-7046">limitation</a> of the Scala typer
and may have a <a href="https://github.com/scala/scala/pull/5284">partial fix soon</a>.</li>
</ol>
<h4 id="the-class-metamorphosis" class="a_section" data-magellan-target="the-class-metamorphosis">The class Metamorphosis<a class="a_hlink" href="#the-class-metamorphosis"></a></h4>
<p>So what should you do to make <code class="hljs">spores-serialization</code> transitively check all your program?
Ensure that all the captured variables in your spores are serializable and closed. If you
have class definitions scattered across different packages, bring them to the same file
and baptise the class hierarchy with <code class="hljs">sealed</code> and <code class="hljs">final</code> as described before.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">scala&gt; <span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">import</span> scala.spores._

scala&gt; <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span></span>
defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span></span>

scala&gt; <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span></span>

scala&gt; <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span></span>

scala&gt; <span class="hljs-comment">// Force cast to Foo</span>
     | <span class="hljs-keyword">val</span> foo1: <span class="hljs-type">Foo</span> = <span class="hljs-type">Baz</span>(<span class="hljs-number">1</span>)
foo1: <span class="hljs-type">Foo</span> = <span class="hljs-type">Baz</span>(<span class="hljs-number">1</span>)

scala&gt; <span class="hljs-keyword">val</span> foo2: <span class="hljs-type">Foo</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Bar</span>(<span class="hljs-number">2</span>)
foo2: <span class="hljs-type">Foo</span> = <span class="hljs-type">Bar</span>@<span class="hljs-number">72e1</span>d7e2

scala&gt; <span class="hljs-keyword">val</span> bar = <span class="hljs-keyword">new</span> <span class="hljs-type">Bar</span>(<span class="hljs-number">2</span>)
bar: <span class="hljs-type">Bar</span> = <span class="hljs-type">Bar</span>@<span class="hljs-number">709392</span>ac

scala&gt; spore {
     |   <span class="hljs-keyword">val</span> capturedFoo1 = foo1
     |   <span class="hljs-keyword">val</span> capturedFoo2 = foo2
     |   <span class="hljs-keyword">val</span> capturedBar = bar
     |   () =&gt; <span class="hljs-comment">// spore logic using `capturedFoo1`, `capturedFoo2` and `capturedBar`</span>
     | }
res1: scala.spores.<span class="hljs-type">NullarySporeWithEnv</span>[<span class="hljs-type">Unit</span>]{<span class="hljs-keyword">val</span> captured: (<span class="hljs-type">Foo</span>, <span class="hljs-type">Foo</span>, <span class="hljs-type">Bar</span>); <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Captured</span> </span>= (<span class="hljs-type">Foo</span>, <span class="hljs-type">Foo</span>, <span class="hljs-type">Bar</span>)} = &lt;function0&gt;
</code></pre>
</div>
<p>The previous example compiles. If you don't seal the hierarchy, <code class="hljs">spores-serialization</code>
outputs the following error:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">[warn] /your/path/<span class="hljs-type">File</span>.scala:<span class="hljs-number">93</span>: <span class="hljs-type">Detected</span> open <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">hierarchy</span> <span class="hljs-title">in</span> `<span class="hljs-title">trait</span> <span class="hljs-title">Foo</span>`.</span>
[warn]   <span class="hljs-type">Transitive</span> inspection cannot ensure that <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">being</span> <span class="hljs-title">extended</span> <span class="hljs-title">somewhere</span> <span class="hljs-title">else</span>. <span class="hljs-title">For</span> <span class="hljs-title">a</span> <span class="hljs-title">complete</span> <span class="hljs-title">serializable</span> <span class="hljs-title">check</span>, <span class="hljs-title">class</span> <span class="hljs-title">hierarchies</span> <span class="hljs-title">need</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">closed</span>.</span>
[warn] 
[warn] <span class="hljs-type">Solution</span>: <span class="hljs-type">Close</span> the <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">hierarchy</span> <span class="hljs-title">by</span> <span class="hljs-title">marking</span> <span class="hljs-title">super</span> <span class="hljs-title">classes</span> <span class="hljs-title">as</span> `<span class="hljs-title">sealed</span>` <span class="hljs-title">and</span> <span class="hljs-title">sub</span> <span class="hljs-title">classes</span> <span class="hljs-title">as</span> `<span class="hljs-title">final</span>`.</span>
[warn]      
[warn]     <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>{<span class="hljs-keyword">val</span> foo: <span class="hljs-type">String</span>}
[warn]           ^
</code></pre>
</div>
<p>Notice that capturing subclasses like <code class="hljs">Bar</code> or <code class="hljs">Baz</code> will never cause an error
because they are final and, by definition, have no subclass.</p>
<h4 id="an-escape-hatch" class="a_section" data-magellan-target="an-escape-hatch">An escape hatch<a class="a_hlink" href="#an-escape-hatch"></a></h4>
<p>The annotation <code class="hljs">@assumeClosed</code> is an escape hatch for users that <em>for some reason</em> cannot
close their class hierarchy. The annotation tells the compiler to assume that the class you're
capturing is closed, but unfortunately no analysis of the subclasses is performed (SI-7046).
Therefore, its use is discouraged and only left for intrepid developers that like risk.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">scala&gt; <span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">import</span> scala.spores._

scala&gt; <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span></span>
defined <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Foo</span></span>

scala&gt; <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">b: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span></span>

scala&gt; <span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">s: <span class="hljs-type">String</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baz</span></span>

scala&gt; <span class="hljs-comment">// Force cast to Foo</span>
     | <span class="hljs-keyword">val</span> riskyFoo: <span class="hljs-type">Foo</span> = <span class="hljs-type">Baz</span>(<span class="hljs-string">"1"</span>)
riskyFoo: <span class="hljs-type">Foo</span> = <span class="hljs-type">Baz</span>(<span class="hljs-number">1</span>)

scala&gt; <span class="hljs-keyword">val</span> s = spore {
     |   <span class="hljs-keyword">val</span> capturedFoo = (riskyFoo: <span class="hljs-type">Foo</span> <span class="hljs-meta">@assumeClosed</span>)
     |   () =&gt; <span class="hljs-comment">// spore logic</span>
     | }
s: scala.spores.<span class="hljs-type">NullarySporeWithEnv</span>[<span class="hljs-type">Unit</span>]{<span class="hljs-keyword">val</span> captured: <span class="hljs-type">Foo</span> <span class="hljs-meta">@scala</span>.spores.assumeClosed; <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Captured</span> </span>= <span class="hljs-type">Foo</span> <span class="hljs-meta">@scala</span>.spores.assumeClosed} = &lt;function0&gt;
</code></pre>
</div>
<h3 id="abstracting-over-the-logic" class="a_section" data-magellan-target="abstracting-over-the-logic">Abstracting over the logic<a class="a_hlink" href="#abstracting-over-the-logic"></a></h3>
<p>Sooner or later, your logic may become repetitive. <code class="hljs">spores-serialization</code> is capable
of allowing users to abstract over their logic and define spores in places where
the captured types are not fully defined.</p>
<p>For the following code snippet, assume that <code class="hljs">Foo</code> is a closed class hierarchy.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">scala&gt; <span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">import</span> scala.spores._

scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Foo</span>](<span class="hljs-params">val wrapped: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>]</span>) </span>{
     |   <span class="hljs-keyword">val</span> zippingSpore = spore {
     |     <span class="hljs-keyword">val</span> captured = wrapped
     |     (xs: <span class="hljs-type">List</span>[<span class="hljs-type">Foo</span>]) =&gt; xs.zip(captured)
     |   }
     | }
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span></span>
</code></pre>
</div>
<p>And if the wrapper is <code class="hljs">Serializable</code>, you can even send it accross the wire:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">scala&gt; <span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">import</span> scala.spores._

scala&gt; <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Foo</span>](<span class="hljs-params">val wrapped: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>{
     |   <span class="hljs-keyword">val</span> zippingSpore = spore {
     |     <span class="hljs-keyword">val</span> captured = wrapped
     |     (xs: <span class="hljs-type">List</span>[<span class="hljs-type">Foo</span>]) =&gt; xs.zip(captured)
     |   }
     | }
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span></span>

scala&gt; <span class="hljs-keyword">val</span> wrapper = <span class="hljs-keyword">new</span> <span class="hljs-type">Wrapper</span>(<span class="hljs-type">List</span>(<span class="hljs-type">Baz</span>(<span class="hljs-string">"Hello"</span>), <span class="hljs-type">Baz</span>(<span class="hljs-string">"Hello"</span>)))
wrapper: <span class="hljs-type">Wrapper</span>[<span class="hljs-type">Baz</span>] = <span class="hljs-type">Wrapper</span>@<span class="hljs-number">20589162</span>

scala&gt; <span class="hljs-keyword">val</span> s = spore {
     |   <span class="hljs-keyword">val</span> serializedWrapper = wrapper
     |   () =&gt; serializedWrapper
     | }
&lt;console&gt;:<span class="hljs-number">29</span>: warning: <span class="hljs-type">Detected</span> open <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">hierarchy</span> <span class="hljs-title">in</span> `<span class="hljs-title">&lt;refinement</span> <span class="hljs-title">of</span> <span class="hljs-title">List</span>[<span class="hljs-type">Foo</span>] <span class="hljs-title">=&gt;</span> <span class="hljs-title">List</span>[(<span class="hljs-type">Foo</span>, <span class="hljs-type">T</span>)]<span class="hljs-title">&gt;</span>`.</span>
  <span class="hljs-type">Transitive</span> inspection cannot ensure that &lt;refinement of <span class="hljs-type">List</span>[<span class="hljs-type">Foo</span>] =&gt; <span class="hljs-type">List</span>[(<span class="hljs-type">Foo</span>, <span class="hljs-type">T</span>)]&gt; is not being extended somewhere <span class="hljs-keyword">else</span>. <span class="hljs-type">For</span> a complete serializable check, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">hierarchies</span> <span class="hljs-title">need</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">closed</span>.</span>

<span class="hljs-type">Solution</span>: <span class="hljs-type">Close</span> the <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">hierarchy</span> <span class="hljs-title">by</span> <span class="hljs-title">marking</span> <span class="hljs-title">super</span> <span class="hljs-title">classes</span> <span class="hljs-title">as</span> `<span class="hljs-title">sealed</span>` <span class="hljs-title">and</span> <span class="hljs-title">sub</span> <span class="hljs-title">classes</span> <span class="hljs-title">as</span> `<span class="hljs-title">final</span>`.</span>

         <span class="hljs-keyword">val</span> zippingSpore = spore {
             ^
s: scala.spores.<span class="hljs-type">NullarySporeWithEnv</span>[<span class="hljs-type">Wrapper</span>[<span class="hljs-type">Baz</span>]]{<span class="hljs-keyword">val</span> captured: <span class="hljs-type">Wrapper</span>[<span class="hljs-type">Baz</span>]; <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Captured</span> </span>= <span class="hljs-type">Wrapper</span>[<span class="hljs-type">Baz</span>]} = &lt;function0&gt;
</code></pre>
</div>
<p>Why are these working examples? Because <code class="hljs">Foo</code> is ensured to be an upper bound of
the type parameter and <code class="hljs">Foo</code> is a closed class hierarchy.</p>
<p>While the previous examples work, users can also set the upper bound to be
<code class="hljs">Serializable</code>:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">scala&gt; <span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">import</span> scala.spores._

scala&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span>[<span class="hljs-type">T</span> &lt;: <span class="hljs-type">Serializable</span>](<span class="hljs-params">val wrapped: <span class="hljs-type">List</span>[<span class="hljs-type">T</span>]</span>) </span>{
     |   <span class="hljs-keyword">val</span> zippingSpore = spore {
     |     <span class="hljs-keyword">val</span> captured = wrapped
     |     (xs: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]) =&gt; xs.zip(captured)
     |   }
     | }
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper</span></span>
</code></pre>
</div>
<p>But this results in the following warning when flag X is passed (TBD):</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code>TBD
</code></pre>
</div>
<p>Generally, verifying that a type parameter extends <code class="hljs">scala.Serializable</code> is not enough
to ensure the lack of type members because &quot;serializable&quot; classes may have fields
that are not. The previous code snippet is <strong>not the recommended way</strong> to use <code class="hljs">spores-serialization</code>.
It's better to allow the compiler plugin to do all the work if you don't necessarily
like debugging a runtime serialization error on a Sunday night.</p>
<h3 id="transient-fields" class="a_section" data-magellan-target="transient-fields">Transient fields<a class="a_hlink" href="#transient-fields"></a></h3>
<p>In Java, variables may be marked <code class="hljs">transient</code> to indicate that they are not part of the persistent
state of an object and are therefore not serialized (see <a href="https://en.wikibooks.org/wiki/Java_Programming/Keywords/transient">this</a> and the <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.3">Java Language Specification</a>).
In Scala, you can achieve the same goal by annotating the fields with <code class="hljs">@transient</code>.</p>
<p>By definition, transient fields are not part of the analyzed field, and
<code class="hljs">spores-serialization</code> ignores its type even if it's not serializable.
Under the hood, when Java initializes the deserialized class instance, a transient
field will hold no value, so make sure that transient fields are not used in the
logic of your program.</p>
<h3 id="serializable-value-classes" class="a_section" data-magellan-target="serializable-value-classes">Serializable value classes<a class="a_hlink" href="#serializable-value-classes"></a></h3>
<p>By definition, value classes can <em>only</em> extend <code class="hljs">AnyVal</code>, which means they cannot be <code class="hljs">{java.io, scala}.Serializable</code>.
To overcome this limitation, the compiler plugin uses implicits to prove that a value class <code class="hljs">FooVal</code> is serializable.
For proving it, you need to provide an implicit <code class="hljs">CanSerialize[FooVal]</code> in the scope of
the spore definition.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">scala&gt; <span class="hljs-keyword">import</span> scala.spores._
<span class="hljs-keyword">import</span> scala.spores._

scala&gt; <span class="hljs-comment">// Value class definition somewhere</span>
     | <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooVal</span>(<span class="hljs-params">i: <span class="hljs-type">Int</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">AnyVal</span></span>
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooVal</span></span>

scala&gt; <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FooImplicit</span> </span>{
     |   <span class="hljs-keyword">implicit</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FooIsSerializable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CanSerialize</span>[<span class="hljs-type">FooVal</span>]</span>
     | }
defined <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FooImplicit</span></span>

scala&gt; <span class="hljs-comment">// Spore definition somewhere else</span>
     | <span class="hljs-keyword">val</span> foo = <span class="hljs-type">FooVal</span>(<span class="hljs-number">5</span>)
foo: <span class="hljs-type">FooVal</span> = <span class="hljs-type">FooVal</span>(<span class="hljs-number">5</span>)

scala&gt; <span class="hljs-keyword">import</span> <span class="hljs-type">FooImplicit</span>._
<span class="hljs-keyword">import</span> <span class="hljs-type">FooImplicit</span>._

scala&gt; <span class="hljs-keyword">val</span> s = spore {
     |   <span class="hljs-keyword">val</span> captured = foo
     |   () =&gt; <span class="hljs-comment">// spore logic using `captured`</span>
     | }
s: scala.spores.<span class="hljs-type">NullarySporeWithEnv</span>[<span class="hljs-type">Unit</span>]{<span class="hljs-keyword">val</span> captured: <span class="hljs-type">FooVal</span>; <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Captured</span> </span>= <span class="hljs-type">FooVal</span>} = &lt;function0&gt;
</code></pre>
</div>
<p>Thanks to the definition of <code class="hljs">FooIsSerializable</code> and the <code class="hljs">import FooImplicit._</code> in the spore
definition, the compiler plugin is able to prove that the use of <code class="hljs">FooVal</code> is safe.</p>
<blockquote class="note">
<p>Non-primitive value classes <em>may</em> be non-serializable. Its serialization fails when they require
allocation inside the spore body, because they need to be <a href="http://docs.scala-lang.org/overviews/core/value-classes.html">instantiated as a class <code class="hljs">Foo</code>
instead of avoiding the runtime object allocation</a>. This happens when:</p>
<ol>
<li>a value class is treated as another type.</li>
<li>a value class is assigned to an array.</li>
<li>doing runtime type tests, such as pattern matching.</li>
</ol>
<p>Therefore, you cannot use value classes if you use them in any situation that requires boxing.
This is a fundamental limitation of value classes that may be fixed in the future. For now,
the compiler plugin does not catch the misuse of value classes inside spores, so if you decide
to use them, be careful.</p>
</blockquote>
<h2 id="future-ideas" class="a_section" data-magellan-target="future-ideas">Future ideas<a class="a_hlink" href="#future-ideas"></a></h2>
<p>Do you want <code class="hljs">spores-serialization</code> to be smarter? To support a use case that it's
not yet implemented?</p>
<p>As a compiler plugin, <code class="hljs">spores-serialization</code> is capable of doing more than just
static type analysis. <a href="https://github.com/jvican/spores/issues">Here are some ideas for the future</a>
that may be considered to be implemented depending on the community's response. Come to discuss them
at <a href="https://contributors.scala-lang.org/">Discourse</a>(<strong>TBD</strong>) or the issue tracker,
and propose your ideas to make everyone's life easier.</p>

              </main>
              
              
                <div data-sticky-container class="small-12 medium-12 large-2 large-order-1 columns a_sitenav_container">
                  <nav class="a_sitenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                    
                  <ul>
                     
  <li >
    
      <a href="spores.html">Spores</a>
    
    
  </li>
  
  <li >
    
      <a href="getting-started.html">Getting started</a>
    
    
  </li>
  
  <li  class="a_thispage" >
    
      <a href="java-serialization.html">Serializing spores</a>
    
    
  </li>
 
                  </ul>
                  </nav>
                </div>
              
              
              
                <div class="small-12 medium-12 large-2 large-order-3 columns a_show-for-xlarge" data-sticky-container>
                  <nav class="a_pagenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                     <header><p>On This Page</p>
</header> 
                    <ul class="vertical menu" data-magellan>
                       
  <li>
    
       <a href="#serializing-spores">Serializing spores</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#goal">Goal</a> 
    
    
  </li>
  
  <li>
    
       <a href="#installation">Installation</a> 
    
    
  </li>
  
  <li>
    
       <a href="#quickstart">Quickstart</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#an-example">An example</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#basics">Basics</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#closed-class-hierarchies">Closed class hierarchies</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#the-class-hierarchy">The class hierarchy</a> 
    
    
  </li>
  
  <li>
    
       <a href="#motivation-of-sealed-class-hierarchies">Motivation of sealed class hierarchies</a> 
    
    
  </li>
  
  <li>
    
       <a href="#the-class-metamorphosis">The class Metamorphosis</a> 
    
    
  </li>
  
  <li>
    
       <a href="#an-escape-hatch">An escape hatch</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#abstracting-over-the-logic">Abstracting over the logic</a> 
    
    
  </li>
  
  <li>
    
       <a href="#transient-fields">Transient fields</a> 
    
    
  </li>
  
  <li>
    
       <a href="#serializable-value-classes">Serializable value classes</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#future-ideas">Future ideas</a> 
    
    
  </li>
  </ul>
    
  </li>
 
                    </ul>
                  </nav>
                </div>
              
            </div>
          </div>
        </div>
      </div>
      
      <footer class="small-12 medium-12 large-12 columns align-self-bottom a_footer">
        <div class="row">
          <div class="small-12 medium-12 large-12 columns top-bar">
            <div class="top-bar-left">
              <p>Generated with <a href="https://github.com/szeiger/ornate">Ornate</a>.</p>

            </div>
            <div class="top-bar-right">
              <p>© Scala Center 2016</p>

            </div>
          </div>
        </div>
      </footer>
    </div>
    <script src="_theme/js/jquery.min.js"></script>
    <script src="_theme/js/what-input.min.js"></script>
    <script src="_theme/js/foundation.min.js"></script>
    
    <script src="_theme/js/app.js"></script>
    
  </body>
</html>
