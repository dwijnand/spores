<!DOCTYPE html>
<html class="no-js" lang="eng" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Getting started</title>
    <link rel="stylesheet" href="_theme/css/foundation.min.css">
    <link rel="stylesheet" href="_theme/css/app.css">
     <link rel="stylesheet" href="_theme/css/highlight.js/styles/github-gist.css"> 
  </head>
  <body>
    <div class="expanded row">
      <div class="small-12 medium-12 large-12 columns align-self-top">
        <div class="row">
          
          <header class="large-12 columns align-self-top a_header">
            <div class="row">
              <div class="large-12 columns a_limited top-bar">
                <div class="top-bar-left">
                  <p>Spores</p>

                </div>
                <div class="top-bar-right align-right row">
                  
                  
                    <form action="site-search.html" method="get" class="align-right a_search">
                      <input name="q" type="search"  placeholder="Search
" >
                      <button><img alt="&#1F50D;" src="_theme/images/images/search.svg" /></button>
                    </form>
                  
                </div>
              </div>
            </div>
          </header>
          
          <div class="small-12 medium-12 large-12 columns align-self-top a_limited a_main">
            <div class="row">
              
              <main class="columns large-order-2 sections" id="_sections">
                <h1 id="getting-started" class="a_section" data-magellan-target="getting-started">Getting started<a class="a_hlink" href="#getting-started"></a></h1>
<h2 id="installation" class="a_section" data-magellan-target="installation">Installation<a class="a_hlink" href="#installation"></a></h2>
<p>Add the following sbt settings to your <code class="hljs">build.sbt</code>:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">libraryDependencies += <span class="hljs-string">"ch.epfl.scala"</span> %% <span class="hljs-string">"spores"</span> % <span class="hljs-string">"0.4.2"</span>
</code></pre>
</div>
<blockquote class="note">
<p>This artifacts is only compatible with Scala 2.11.x.
A <a href="https://issues.scala-lang.org/browse/SI-10009">bug in 2.12.0</a> prevents us from releasing
a compatible version. <code class="hljs">spores</code> will be probably released for 2.12.1.</p>
</blockquote>
<blockquote class="warning">
<p>If you want to use spores for serialization, read the <a href="getting-started.html#basics">Basics</a>
and jump to the <a href="java-serialization.html">Java Serialization guide</a>.</p>
</blockquote>
<h2 id="basics" class="a_section" data-magellan-target="basics">Basics<a class="a_hlink" href="#basics"></a></h2>
<p>Spores have a few modes of usage. The simplest form is:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">val</span> s = spore {
  <span class="hljs-keyword">val</span> h = helper
  (x: <span class="hljs-type">Int</span>) =&gt; {
    <span class="hljs-keyword">val</span> result = x + <span class="hljs-string">" "</span> + h.toString
    println(<span class="hljs-string">"The result is: "</span> + result)
  }
}
</code></pre>
</div>
<p>In this example, no transformation is actually performed. Instead, the
compiler simply ensures that the spore is <em>well-formed</em>, i.e., anything that's
captured is explicitly listed as a value definition before the spore's
closure. This ensures that the enclosing <code class="hljs">this</code> instance is not accidentally
captured, in this example.</p>
<p>Spores can also be used in for-comprehensions:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">for</span> { i &lt;- collection
      j &lt;- doSomething(i)
} <span class="hljs-keyword">yield</span> <span class="hljs-string">s"<span class="hljs-subst">${capture(i)}</span>: result: <span class="hljs-subst">$j</span>"</span>
</code></pre>
</div>
<p>Here, the fact that a spore is created is implicit, that is, the <code class="hljs">spore</code>
marker is not used explicitly. Spores come into play because the underlying
<code class="hljs">map</code> method of the type of <code class="hljs">doSomething(i)</code> takes a spore as a parameter. The
<code class="hljs">capture(i)</code> syntax is an alternative way of declaring captured variables, in
particular for use in for-comprehensions.</p>
<p>Finally, a regular function literal can be used as a spore. That is, a method
that expects a spore can be passed a function literal so long as the function
literal is well-formed.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendOverWire</span></span>(s: <span class="hljs-type">Spore</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>]): <span class="hljs-type">Unit</span> = ...
sendOverWire((x: <span class="hljs-type">Int</span>) =&gt; x * x - <span class="hljs-number">2</span>)
</code></pre>
</div>
<h2 id="design" class="a_section" data-magellan-target="design">Design<a class="a_hlink" href="#design"></a></h2>
<p>The main idea behind spores is to provide an alternative way to create
closure-like objects, in a way where the environment is controlled.</p>
<p>A spore is created as follows.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">val</span> s = spore {
  <span class="hljs-keyword">val</span> h = helper
  (x: <span class="hljs-type">Int</span>) =&gt; {
    <span class="hljs-keyword">val</span> result = x + <span class="hljs-string">" "</span> + h.toString
    println(<span class="hljs-string">"The result is: "</span> + result)
  }
}
</code></pre>
</div>
<p>The body of a spore consists of two parts:</p>
<ol>
<li><strong>the spore header:</strong> a sequence of local value (val) declarations only, and</li>
<li><strong>the closure</strong>.</li>
</ol>
<p>In general, a <code class="hljs">spore { ... }</code> expression has the following shape.</p>
<p>Note that the value declarations described in point 1 above can be <code class="hljs">implicit</code>
but not <code class="hljs">lazy</code>.</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">spore {
  <span class="hljs-keyword">val</span> x_1: <span class="hljs-type">T_1</span> = init_1
  ...
  <span class="hljs-keyword">val</span> x_n: <span class="hljs-type">T_n</span> = init_n
  (p_1: <span class="hljs-type">S_1</span>, ..., p_m: <span class="hljs-type">S_m</span>) =&gt; {
    &lt;body&gt;
  }
}
</code></pre>
</div>
<p>The types <code class="hljs">T_1, ..., T_n</code> can also be inferred.</p>
<p>The closure of a spore has to satisfy the following rule. All free variables
of the closure body have to be either:</p>
<ol>
<li>parameters of the closure, or</li>
<li>declared in the preceding sequence of local value declarations,</li>
<li>marked using <code class="hljs">capture</code> (see corresponding section below), or</li>
<li><em>statically</em> accessible (members of objects | packages).</li>
</ol>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span>
<span class="hljs-keyword">val</span> outer1 = <span class="hljs-number">0</span>
<span class="hljs-keyword">val</span> outer2 = <span class="hljs-type">Person</span>(<span class="hljs-string">"Jim"</span>, <span class="hljs-number">35</span>)
<span class="hljs-keyword">val</span> s = spore {
  <span class="hljs-keyword">val</span> inner = outer2
  (x: <span class="hljs-type">Int</span>) =&gt; {
    <span class="hljs-string">s"The result is: <span class="hljs-subst">${x + inner.age + outer1}</span>"</span>
  }
}
</code></pre>
</div>
<p>In the above example, the spore's closure is invalid, and would be rejected
during compilation. The reason is that the variable <code class="hljs">outer1</code> is neither a
parameter of the closure nor one of the spore's value declarations (the only
value declaration is: <code class="hljs">val inner = outer2</code>).</p>
<h3 id="evaluation-semantics" class="a_section" data-magellan-target="evaluation-semantics">Evaluation Semantics<a class="a_hlink" href="#evaluation-semantics"></a></h3>
<p><a name="evaluation-semantics"></a></p>
<p>In order to make the runtime behavior of a spore as intuitive as possible, the
design leaves the evaluation semantics unchanged compared to regular closures.
Basically, leaving out the <code class="hljs">spore</code> marker results in a closure with the same
runtime behavior.</p>
<p>For example,</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">spore {
  <span class="hljs-keyword">val</span> l = <span class="hljs-keyword">this</span>.logger
  () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">LoggingActor</span>(l)
}
</code></pre>
</div>
<p>and</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">{
  <span class="hljs-keyword">val</span> l = <span class="hljs-keyword">this</span>.logger
  () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">LoggingActor</span>(l)
}
</code></pre>
</div>
<p>have the same behavior at runtime. The rationale for this design decision is
that the runtime behavior of closure-heavy code can already be hard to reason
about. It would become even more difficult if we would introduce additional
rules for spores.</p>
<h3 id="spore-type" class="a_section" data-magellan-target="spore-type">Spore Type<a class="a_hlink" href="#spore-type"></a></h3>
<p>The type of the spore is determined by the type and arity of the closure. If
the closure has type <code class="hljs">A =&gt; B</code>, then the spore has type <code class="hljs">Spore[A, B]</code>. For
convenience we also define spore types for two or more parameters.</p>
<p>In example 3, the type of s is <code class="hljs">Spore[Int, Unit]</code>.
Implementation
The spore construct is a macro which</p>
<ul>
<li>performs the checking described above, and which</li>
<li>replaces the spore body so that it creates an instance of one of the Spore traits, according to the arity of the closure of the spore.</li>
</ul>
<p>The <code class="hljs">Spore</code> trait for spores of arity 1 is declared as follows:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Spore</span>[-<span class="hljs-type">T</span>, +<span class="hljs-type">R</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">Function1</span>[<span class="hljs-type">T</span>, <span class="hljs-type">R</span>]</span>
</code></pre>
</div>
<p>For each function arity there exists a corresponding <code class="hljs">Spore</code> trait of the same
arity (called <code class="hljs">Spore2</code>, <code class="hljs">Spore3</code>, etc.)</p>
<h3 id="implicit-conversion" class="a_section" data-magellan-target="implicit-conversion">Implicit Conversion<a class="a_hlink" href="#implicit-conversion"></a></h3>
<p>Regular function literals can be implicitly converted to spores. This implicit
conversion has two benefits:</p>
<ol>
<li>it enables the use of spores in for-comprehensions.</li>
<li>it makes the spore syntax more lightweight, which is important in frameworks such as <a href="http://spark.incubator.apache.org/">Spark</a> where users often create many small function literals.</li>
</ol>
<p>This conversion is defined as a member of the <code class="hljs">Spore</code> companion object, so
it's always in the implicit scope when passing a function literal as a method
argument when a <code class="hljs">Spore</code> is expected. For example, one can do the following:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendOverWire</span></span>(s: <span class="hljs-type">Spore</span>[<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>]): <span class="hljs-type">Unit</span> = ...
sendOverWire((x: <span class="hljs-type">Int</span>) =&gt; x * x - <span class="hljs-number">2</span>)
</code></pre>
</div>
<p>This is arguably much lighter-weight than having to declare a spore before
passing it to <code class="hljs">sendOverWire</code>.</p>
<p>In general, the implicit conversion will be successful if and only if the
function literal is well-formed according to the spore rules (defined above in
the <em>Design</em> section). Note that <em>only function literals can be converted to spores</em>.
This is due to the fact that the body of the function literal has to be checked
by the spore macro to make sure that the conversion is safe. For <em>named</em> function
values (i.e., not literals) on the other hand, it's not guaranteed that the
function value's body is available for the spore macro to check.</p>
<h3 id="capture-syntax-and-for-comprehensions" class="a_section" data-magellan-target="capture-syntax-and-for-comprehensions">Capture Syntax and For-Comprehensions<a class="a_hlink" href="#capture-syntax-and-for-comprehensions"></a></h3>
<p>To enable the use of spores with for-comprehensions, a <code class="hljs">capture</code> syntax has
been introduced to assist in the spore checking.</p>
<p>To see why this is necessary, let's start with an example. Suppose we have a
type for distributed collections:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">DCollection</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">B</span>](sp: <span class="hljs-type">Spore</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]): <span class="hljs-type">DCollection</span>[<span class="hljs-type">B</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">B</span>](sp: <span class="hljs-type">Spore</span>[<span class="hljs-type">A</span>, <span class="hljs-type">DCollection</span>[<span class="hljs-type">B</span>]]): <span class="hljs-type">DCollection</span>[<span class="hljs-type">B</span>]
}
</code></pre>
</div>
<p>This type, <code class="hljs">DCollection</code>, might be implemented in a way where the data is
distributed across machines in a cluster. Thus, the functions passed to <code class="hljs">map</code>,
<code class="hljs">flatMap</code>, etc. have to be serializable. A simple way to ensure this is to
require these arguments to be spores. However, we also would like for-comprehensions
like the following to work:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lookup</span></span>(i: <span class="hljs-type">Int</span>): <span class="hljs-type">DCollection</span>[<span class="hljs-type">Int</span>] = ...
<span class="hljs-keyword">val</span> indices: <span class="hljs-type">DCollection</span>[<span class="hljs-type">Int</span>] = ...

<span class="hljs-keyword">for</span> { i &lt;- indices
      j &lt;- lookup(i)
} <span class="hljs-keyword">yield</span> j + i
</code></pre>
</div>
<p>A problem here is that the desugaring done by the compiler for
for-comprehensions doesn't know anything about spores. This is what
the compiler produces from the above expression:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">indices.flatMap(i =&gt; lookup(i).map(j =&gt; j + i))
</code></pre>
</div>
<p>The problem is that <code class="hljs">(j =&gt; j + i)</code> is not a spore. Furthermore, making it a
spore is not straightforward, as we can't change the way for-comprehensions
are translated.</p>
<p>We can overcome this by using the implicit conversion introduced in the
previous section to convert the function literal implicitly to a spore.</p>
<p>However, in continuing to look at this example, it's evident that the lambda
still has the wrong shape. The captured variable <code class="hljs">i</code> is not declared in the
spore header (the list of value definitions preceding the closure within the
spore), like a spore demands.</p>
<p>We can overcome this using the <code class="hljs">capture</code> syntax. That is, instead of having to write:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">{
  <span class="hljs-keyword">val</span> captured = i
  j =&gt; j + i
}
</code></pre>
</div>
<p>One can also write:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala">(j =&gt; j + capture(i))
</code></pre>
</div>
<p>Thus, the above for-comprehension can be rewritten using spores and <code class="hljs">capture</code>
as follows:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">for</span> { i &lt;- indices
      j &lt;- lookup(i)
} <span class="hljs-keyword">yield</span> j + capture(i)
</code></pre>
</div>
<p>Here, <code class="hljs">i</code> is &quot;captured&quot; as it occurs syntactically after the arrow of another
generator (it occurs after <code class="hljs">j &lt;- lookup(i)</code>, the second generator in the
for-comprehension).</p>
<blockquote class="note">
<p><code class="hljs">capture</code> can only capture identifiers. This means that paths like
<code class="hljs">capture(foo.bar.baz)</code> will fail and should be rewritten to <code class="hljs">capture(foo).bar.baz</code>.</p>
<p>The reason why captured expressions are restricted to identifiers is that
otherwise the <code class="hljs">capture</code> function will change the evaluation semantics.
Removing <code class="hljs">spore</code> from the block could potentially change the way the captured
expressions are evaluated. This would complicate the reasoning about spore-based
code (see the section <a href="getting-started.html#evaluation-semantics">Evaluation Semantics</a> above).</p>
</blockquote>
<h3 id="macro-expansion" class="a_section" data-magellan-target="macro-expansion">Macro Expansion<a class="a_hlink" href="#macro-expansion"></a></h3>
<p>An invocation of the spore macro expands the spore's body as follows. Given
the general shape of a spore as shown above, the spore macro produces the
following code:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">new</span> &lt;spore implementation <span class="hljs-class"><span class="hljs-keyword">class</span><span class="hljs-title">&gt;</span>[<span class="hljs-type">S_1</span>, ..., <span class="hljs-type">S_m</span>, <span class="hljs-type">R</span>](<span class="hljs-params">{
  val x_1: <span class="hljs-type">T_1</span> = init_1
  ...
  val x_n: <span class="hljs-type">T_n</span> = init_n
  (p_1: <span class="hljs-type">S_1</span>, ..., p_m: <span class="hljs-type">S_m</span></span>) <span class="hljs-title">=&gt;</span> </span>{
    &lt;body&gt;
  }
})
</code></pre>
</div>
<p>Note that, after checking, the spore macro need not do any further
transformation, since implementation details such as unneeded remaining outer
references are removed by the new backend intended for inclusion in Scala
2.11. It's also useful to note that in some cases these unwanted outer
references are already removed by the existing backend.</p>
<p>The spore implementation classes follow a simple pattern. For example, for
arity 1, the implementation class is declared as follows:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SporeImpl</span>[-<span class="hljs-type">T</span>, +<span class="hljs-type">R</span>](<span class="hljs-params">f: <span class="hljs-type">T</span> =&gt; <span class="hljs-type">R</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Spore</span>[<span class="hljs-type">T</span>, <span class="hljs-type">R</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">R</span> = f(x)
}
</code></pre>
</div>
<h3 id="type-inference" class="a_section" data-magellan-target="type-inference">Type Inference<a class="a_hlink" href="#type-inference"></a></h3>
<p>Similar to regular functions and closures, the type of a spore should be
inferred. Inferring the type of a spore amounts to inferring the type
arguments when instantiating a spore implementation class:</p>
<div class="row">
<pre class="hljs small-expand columns a_xscroll"><code class="language-scala"><span class="hljs-keyword">new</span> &lt;spore implementation <span class="hljs-class"><span class="hljs-keyword">class</span><span class="hljs-title">&gt;</span>[<span class="hljs-type">S_1</span>, ..., <span class="hljs-type">S_m</span>, <span class="hljs-type">R</span>](<span class="hljs-params">{
  // ...
}</span>)</span>
</code></pre>
</div>
<p>In the above expression, the type arguments <code class="hljs">S_1, ..., S_m</code>, and <code class="hljs">R</code> should be
inferred from the expected type.</p>
<p>Our current proposal is to solve this type inference problem in the context of
the integration of Java SAM closures into Scala. Given that it is planned to
eventually support such closures, and to support type inference for these
closures as well, we plan to piggyback on the work done on type inference for
SAMs in general to achieve type inference for spores.</p>

              </main>
              
              
                <div data-sticky-container class="small-12 medium-12 large-2 large-order-1 columns a_sitenav_container">
                  <nav class="a_sitenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                    
                  <ul>
                     
  <li >
    
      <a href="spores.html">Spores</a>
    
    
  </li>
  
  <li  class="a_thispage" >
    
      <a href="getting-started.html">Getting started</a>
    
    
  </li>
  
  <li >
    
      <a href="java-serialization.html">Serializing spores</a>
    
    
  </li>
 
                  </ul>
                  </nav>
                </div>
              
              
              
                <div class="small-12 medium-12 large-2 large-order-3 columns a_show-for-xlarge" data-sticky-container>
                  <nav class="a_pagenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                     <header><p>On This Page</p>
</header> 
                    <ul class="vertical menu" data-magellan>
                       
  <li>
    
       <a href="#getting-started">Getting started</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#installation">Installation</a> 
    
    
  </li>
  
  <li>
    
       <a href="#basics">Basics</a> 
    
    
  </li>
  
  <li>
    
       <a href="#design">Design</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#evaluation-semantics">Evaluation Semantics</a> 
    
    
  </li>
  
  <li>
    
       <a href="#spore-type">Spore Type</a> 
    
    
  </li>
  
  <li>
    
       <a href="#implicit-conversion">Implicit Conversion</a> 
    
    
  </li>
  
  <li>
    
       <a href="#capture-syntax-and-for-comprehensions">Capture Syntax and For-Comprehensions</a> 
    
    
  </li>
  
  <li>
    
       <a href="#macro-expansion">Macro Expansion</a> 
    
    
  </li>
  
  <li>
    
       <a href="#type-inference">Type Inference</a> 
    
    
  </li>
  </ul>
    
  </li>
  </ul>
    
  </li>
 
                    </ul>
                  </nav>
                </div>
              
            </div>
          </div>
        </div>
      </div>
      
      <footer class="small-12 medium-12 large-12 columns align-self-bottom a_footer">
        <div class="row">
          <div class="small-12 medium-12 large-12 columns top-bar">
            <div class="top-bar-left">
              <p>Generated with <a href="https://github.com/szeiger/ornate">Ornate</a>.</p>

            </div>
            <div class="top-bar-right">
              <p>© Scala Center 2016</p>

            </div>
          </div>
        </div>
      </footer>
    </div>
    <script src="_theme/js/jquery.min.js"></script>
    <script src="_theme/js/what-input.min.js"></script>
    <script src="_theme/js/foundation.min.js"></script>
    
    <script src="_theme/js/app.js"></script>
    
  </body>
</html>
